\documentclass[norsk,a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx} %for å inkludere grafikk
\usepackage{verbatim} %for å inkludere filer med tegn LaTeX ikke liker
\usepackage{amsmath}
\usepackage{float}
\usepackage{color}
\usepackage{listings}
\usepackage{hyperref}
\lstset{language=c++}
\lstset{basicstyle=\small}
\lstset{backgroundcolor=\color{white}}
\lstset{frame=single}
\lstset{stringstyle=\ttfamily}
\lstset{keywordstyle=\color{red}\bfseries}
\lstset{commentstyle=\itshape\color{blue}}
\lstset{showspaces=false}
\lstset{showstringspaces=false}
\lstset{showtabs=false}
\lstset{breaklines}
\lstset{postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}}


\title{FYS3150 - Computational Physics\\\vspace{2mm} \Large{Project 2}}
\author{\large Richard Fauli\\ Dorthea Gjestvang\\ Even Nordhagen}
\date{\today}
\begin{document}

\maketitle

\begin{abstract}
\end{abstract}
\begin{itemize}
\item Github repository containing programs and results are in: \url{https://github.com/richaraf/Comphys_projects/tree/master/Project_2}
\end{itemize}
\section{Introduction}

\section{Theory}
If we consider a set of vectors $\textbf{v}_i$ and an orthogonal matrix U. 

\section{Method}
\subsection*{Jacobi's method}
In this project we are using Jacobi's method, which transforms a matrix A into a diagonal matrix D with the eigenvalues of A on the diagonal. This is done by repeat setting the largest non-diagonal element equal to zero until all the non-diagonal elements are smaller than a tolerance $\varepsilon$. From linear algebra we know that a symmetric matrix always can be transformed into a diagonal matrix, so this should be valid for our specific symmetric matrix described in the theory. For doing this we need a transformation matrix S which sets the largest non-diagonal element to zero:
\begin{equation}
S^T A S=B
\end{equation}
Where B is the transformed A matrix where the largest non-diagonal element is set to zero. S is given by
\setcounter{MaxMatrixCols}{20}
\begin{equation}
S=\begin{pmatrix} 
1	&&0	&&\hdots		&&0		&&0	&&\hdots	&&0 	&&0\\
0	&&1		&&\hdots&&0&&0&&\hdots&&0&&0\\ \vdots&&\vdots&&\ddots&&\vdots&&\vdots&&\ddots&&\vdots&&\vdots\\ 0&&0&&\hdots&&cos\theta&&0&&\hdots&&0&&sin\theta\\
0&&0&&\hdots&&0&&1&&\hdots&&0&&0\\ \vdots&&\vdots&&\ddots&&\vdots&&\vdots&&\ddots&&\vdots&&\vdots\\ 0&&0&&\hdots&&0&&0&&\hdots&&1&&0\\
0&&0&&\hdots&&-sin\theta&&0&&\hdots&&0&&cos\theta\\
\end{pmatrix}
\end{equation}
where the locations of $sin\theta$ and $-sin\theta$ are depending on the indexes of the largest element of A. Therefore we first need to find this, something we can easily do numerically:
\begin{lstlisting}
max = 0;                     	//Largest element
for(k = [0,size A])
   for(l = [0,size A])
      if(k != l)		//Not on diagonal
         if(abs(A(k,l)) > max)
            kmax = k;		//Store indexes of
            lmax = l;		//largest element
            max = abs(A(k,l));
\end{lstlisting}
After the indexes of the largest element are found, we can start doing the Jacobi method (also called Jacobi rotation since the matrix S is a rotation matrix). By doing the multiplication $S^T AS = B$ for an arbitrary matrix A, we will see that B is constructed by
\begin{itemize}
\item $b_{ii}=a_{ii}\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\,\, i\not=k,\quad i\not= l$
\item $b_{ik}=a_{ik}cos\theta-a_{il}sin\theta\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad i\not=k,\quad i\not= l$
\item $b_{il}=a_{il}cos\theta+a_{ik}sin\theta\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\, i\not=k,\quad i\not= l$
\item $b_{kk}=a_{kk}cos^2\theta-2a_{kl}cos\theta sin\theta +a_{ll}sin^2\theta$
\item $b_{ll}=a_{ll}cos^2\theta+2a_{kl}cos\theta sin\theta +a_{kk}sin^2\theta$
\item $b_{kl}=(a_{kk}-a_{ll})cos\theta sin\theta + a_{kl}(cos^2\theta sin^2\theta)$
\end{itemize}
where $i$ is an arbitrary columns or row index, $k$ is the index of the row with the largest non-diagonal number (in A) and $l$ is the index of the column with the largest non-diagonal number. This makes it easy to find B numerically, and by doing Jacobi's method on B a multiple times, the largest non-diagonal element will constantly be smaller. In the theory these elements should be equal to zero when the diagonal elements are equal to the exact eigenvalues, but we can get a good approximation of the eigenvalues even if the largest element is a small number. We implement this by choosing a small tolerance $\varepsilon$ and continue doing Jacobi's method until the largest element is smaller than this. The smaller $\varepsilon$ is, the better approach we have.\par\vspace{3mm}
The eigenvectors are found by
\begin{equation}
\textbf{w}_i=S\textbf{v}_i
\end{equation}
where \textbf{v} is a basis of eigenvectors, S is the transformation matrix and \textbf{w} are the eigenvectors of A. Numerically we are going to do this by updating the matrix R which is the identity matrix in the beginning. 
\begin{itemize}
\item $R_{il}=cos\theta r_{il}+sin\theta r_{ik}$
\item $R_{ik}=-sin\theta r_{il}+cos\theta r_{ik}$
\end{itemize}

\subsection*{Armadillo}
We are also finding the eigenvectors and eigenvalues with Armadillo, just to compare them with the eigenvalues and eigenvectors found by Jacobi's method. For a symmetric matrix, this is done by this script:
\begin{lstlisting}
vec eigval;
mat eigvec;
eig_sym(eigval, eigvec, A);
\end{lstlisting}
where we assume that armadillo is included. 

\subsection*{Tests}
\subsubsection*{Largest element test}
To ensure that the indexes of the non-diagonal largest element are found correctly, we have implemented a test for this. The test is a function which takes $k$ and $l$ as arguments (the indexes of the largest non-diagonal element) and placing the number 1 at this index while the remaining elements are zero. It will not allow us to place the element on the diagonal. Then we have a matrix where we know the exact location of the largest (non-diagonal) element. The next step is to send this matrix into the function which finds the largest element and returns the indexes of this. If this function returns the same indexes as where we placed the largest element, the largest element function passes the test.\par\vspace{3mm}
The reason why we want the test function to take the indexes as arguments, is to be able to vary the test matrix to ensure that the solver is not giving the right result accidentally. 

\subsubsection*{Check of orthogonality}


\section{Results}
\section{Discussion}
\section{References}
\begingroup
\renewcommand{\section}[2]{}
\begin{thebibliography}{}
\bibitem{MHJ15}
  Morten Hjorth-Jensen.
  Computational Physics, Lecture Notes Fall 2015.
  Department of Physics, University of Oslo.
  August 2015.

\end{thebibliography}
\endgroup
\section{Code attachment}
\end{document}